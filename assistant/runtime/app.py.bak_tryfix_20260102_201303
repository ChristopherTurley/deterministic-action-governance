from __future__ import annotations

from urllib.parse import urlparse, parse_qs, unquote

def _normalize_url(u: str) -> str:
    if not u:
        return u
    u = u.strip()
    if u.startswith("//"):
        u = "https:" + u
    try:
        p = urlparse(u)
        if "duckduckgo.com" in (p.netloc or "") and p.path.startswith("/l/"):
            qs = parse_qs(p.query)
            uddg = qs.get("uddg", [None])[0]
            if uddg:
                real = unquote(uddg)
                if real.startswith("//"):
                    real = "https:" + real
                return real
        return u
    except Exception:
        return u


import re
import time
import webbrowser
from dataclasses import dataclass
from typing import Any, Dict, Optional, List, Tuple

from assistant.router import route_text
from assistant.state.store import StateStore
from assistant.voice.speaker import Speaker
from assistant.voice.listener import VoiceListener

try:
    from assistant.runtime.audio_config import configure_sounddevice
except Exception:
    configure_sounddevice = None  # type: ignore

from assistant.web.web_lookup import search_duckduckgo, spoken_compact, summarize

GREET_TEXT = "Welcome back Mister Turley. I have today's rundown ready for you. Say: 'start my day' when you're ready."
MISSION_TEXT = (
    "I'm VERA, a Voice-Enabled Reasoning Assistant. I provide real time dynamic analysis and proactive guidance tailored to your immediate context. "
    "By understanding your voice, screen, and schedule, i ensure you stay focused, organized, and on time throughout your day."
)


@dataclass
class AppConfig:
    wake_required: bool = True
    priority_enabled: bool = True


class VeraApp:
    def __init__(self, *, wake_required: bool = True, priority_enabled: bool = True) -> None:
        self.cfg = AppConfig(wake_required=wake_required, priority_enabled=priority_enabled)
        self.store = StateStore()
        self.speaker = Speaker()
        self.listener = VoiceListener()

        self._last_web_spoken_at: float = 0.0
        self._expecting_tasks: bool = False
        self._tasks: List[Dict[str, Any]] = []
        self._reminders: List[Dict[str, Any]] = []  # {"at": epoch, "msg": str, "fired": bool}

    def speak(self, text: str) -> None:
        try:
            self.speaker.say(text)
        except Exception as e:
            print(f"[AUDIO] speak() failed: {e}")

    def _now_str(self) -> Tuple[str, str]:
        date_str = time.strftime("%A, %B %d, %Y")
        time_str = time.strftime("%I:%M %p").lstrip("0")
        return date_str, time_str

    def _handle_priority_set(self, value: str) -> str:
        self.store.set_priority(value)
        return f"Locked. Your top priority today is: {value}."

    def _handle_priority_get(self) -> str:
        p = self.store.get_priority()
        if not p:
            return "You haven’t set a top priority yet. Say: 'my top priority today is ...'"
        return f"Your top priority is: {p}."

    def _handle_time(self) -> str:
        _, t = self._now_str()
        return f"It’s {t}."

    def _handle_open_link(self, target: Any) -> str:
        links = self.store.get_last_web()
        if not links:
            return "I don’t have anything to open yet. Ask me to search the web first."

        idx = 0
        if target == "it":
            idx = 0
        else:
            try:
                idx = int(target) - 1
            except Exception:
                idx = 0

        if idx < 0 or idx >= len(links):
            return f"I only have {len(links)} results. Say open 1, 2, or 3."

        url = links[idx].get("url", "")
        title = links[idx].get("title", "result")
        if not url:
            return "That result didn’t include a valid link."

        try:
            url = _normalize_url(url)
        webbrowser.open(url)
            return f"Opening {title}."
        except Exception:
            return "I couldn’t open that link."

    def _handle_web_lookup(self, query: str) -> str:
        now = time.time()
        if now - self._last_web_spoken_at < 3.0:
            self._last_web_spoken_at = now
            return "Still searching—one sec."
        self._last_web_spoken_at = now

        print(f"[WEB] Searching: {query}")
        try:
            results = search_duckduckgo(query, limit=3)
        except Exception as e:
            print("[WEB] search failed:", e)
            return "I couldn't reach the web right now."

        if not results:
            return "No results found."

        items: List[Dict[str, Any]] = []
        for r in results:
            items.append({"title": r.title, "url": r.url, "snippet": r.snippet})
        self.store.set_last_web(items)

        # Terminal print
        print("\n[WEB RESULTS]")
        for i, it in enumerate(items, start=1):
            print(f"{i}. {it['title']}\n   {it['url']}\n")

        # Speak titles cleanly + optional micro-summary
        titles_spoken = spoken_compact(results)
        micro = summarize(query, results)
        if micro:
            return f"{titles_spoken}. {micro} Say: open 1, open 2, or open 3."
        return f"{titles_spoken}. Say: open 1, open 2, or open 3."

    def _handle_spotify(self, meta: Dict[str, Any]) -> str:
        cmd = (meta or {}).get("cmd")
        q = (meta or {}).get("query")

        try:
            import assistant.tools.spotify as sp
        except Exception:
            sp = None  # type: ignore

        if cmd == "liked":
            try:
                from assistant.integrations.spotify_control import spotify_play_liked_from_top
                spotify_play_liked_from_top()
                return "Playing your Liked Songs."
            except Exception:
                try:
                    if sp is not None and hasattr(sp, "liked_songs"):
                        sp.liked_songs()
                        return "Playing your Liked Songs."
                except Exception:
                    pass
                return "Spotify command failed."

        if cmd == "pause":
            try:
                if sp is not None and hasattr(sp, "pause"):
                    sp.pause()
                return "Paused."
            except Exception:
                return "Spotify command failed."

        if cmd == "resume":
            try:
                if sp is not None and hasattr(sp, "resume"):
                    sp.resume()
                    return "Playing."
                if sp is not None and hasattr(sp, "play"):
                    sp.play("")
                    return "Playing."
                return "Spotify integration is not available."
            except Exception:
                return "Spotify command failed."

        if cmd == "play":
            try:
                if sp is not None and hasattr(sp, "play"):
                    sp.play(str(q or "").strip())
                    return f"Playing: {q}."
                return "Spotify integration is not available."
            except Exception:
                return "Spotify command failed."

        if cmd == "next":
            try:
                if sp is not None and hasattr(sp, "next_track"):
                    sp.next_track()
                    return "Next."
                return "Spotify integration is not available."
            except Exception:
                return "Spotify command failed."

        if cmd == "previous":
            try:
                if sp is not None and hasattr(sp, "previous_track"):
                    sp.previous_track()
                    return "Previous."
                return "Spotify integration is not available."
            except Exception:
                return "Spotify command failed."

        return "Spotify command failed."

    # -------- Phase 1 planning / reminders --------

    def _parse_time_today(self, text: str) -> Optional[float]:
        """
        Parse times like:
          3pm, 3 pm, 3:15pm, 15:30
        Returns epoch seconds for today local time.
        """
        s = (text or "").lower()

        m = re.search(r"\b(\d{1,2})(?::(\d{2}))?\s*(am|pm)\b", s)
        if m:
            hh = int(m.group(1))
            mm = int(m.group(2) or "0")
            ap = m.group(3)
            if hh == 12:
                hh = 0
            if ap == "pm":
                hh += 12
            now = time.localtime()
            t = time.struct_time((now.tm_year, now.tm_mon, now.tm_mday, hh, mm, 0, now.tm_wday, now.tm_yday, now.tm_isdst))
            return time.mktime(t)

        m2 = re.search(r"\b(\d{1,2}):(\d{2})\b", s)
        if m2:
            hh = int(m2.group(1))
            mm = int(m2.group(2))
            now = time.localtime()
            t = time.struct_time((now.tm_year, now.tm_mon, now.tm_mday, hh, mm, 0, now.tm_wday, now.tm_yday, now.tm_isdst))
            return time.mktime(t)

        return None

    def _add_reminder(self, when_epoch: float, msg: str) -> None:
        if when_epoch <= time.time():
            return
        self._reminders.append({"at": when_epoch, "msg": msg, "fired": False})
        self._reminders.sort(key=lambda x: x["at"])

    def _tick_reminders(self) -> None:
        now = time.time()
        fired_any = False
        for r in self._reminders:
            if not r["fired"] and now >= float(r["at"]):
                r["fired"] = True
                fired_any = True
                self.speak(str(r["msg"]))
                print(f"VERA: {r['msg']}")
        if fired_any:
            # Keep list from growing forever
            self._reminders = [x for x in self._reminders if not x["fired"]]

    def _capture_tasks(self, raw: str) -> str:
        """
        Phase 1 simple intake:
        - Supports comma-separated tasks
        - Detects timed tasks like "walk my dog at 3pm"
        - Adds reminders 10 min + 2 min before
        """
        text = (raw or "").strip()
        if not text:
            return "Tell me your tasks for today. Example: finish Phase 1, create UI, walk Moose at 3pm."

        # Split tasks by comma
        parts = [p.strip() for p in re.split(r",| and ", text) if p.strip()]
        added = 0

        for p in parts:
            when = self._parse_time_today(p)
            task = {"text": p, "time": when}
            self._tasks.append(task)
            added += 1

            if when:
                # 10 min and 2 min reminders
                self._add_reminder(when - 10 * 60, f"Hey Mister Turley — you’re 10 minutes out from: {p}.")
                self._add_reminder(when - 2 * 60, f"Hey Mister Turley — you’re 2 minutes out from: {p}.")

        # If any mentions Moose/dog without time, prompt for time
        if any(("moose" in t["text"].lower() or "dog" in t["text"].lower() or "walk" in t["text"].lower()) and not t["time"] for t in self._tasks):
            return f"Locked {added} tasks. What time do you want to walk Moose? Say: 'walk Moose at 3pm'."

        return f"Locked {added} tasks. Want me to build a focused schedule for these? Say: 'build my schedule'."

    def _build_schedule(self) -> str:
        p = self.store.get_priority() or "your top priority"
        timed = [t for t in self._tasks if t.get("time")]
        untimed = [t for t in self._tasks if not t.get("time")]

        # Very simple schedule suggestion
        lines = []
        if timed:
            lines.append("Anchored items:")
            for t in sorted(timed, key=lambda x: x["time"]):
                tm = time.strftime("%I:%M %p", time.localtime(float(t["time"]))).lstrip("0")
                lines.append(f"- {tm}: {t['text']}")

        if untimed:
            lines.append("Focus blocks (suggested order):")
            lines.append(f"- Block 1 (90m): {p}")
            for i, t in enumerate(untimed, start=2):
                lines.append(f"- Block {i} (60m): {t['text']}")

        if not lines:
            return "You don’t have any tasks saved yet. Tell me your tasks for today."

        return "Here’s a focused plan. " + " ".join(lines)

    # -------- routing --------

    def process_one(self, raw: str) -> str:
        # If we're in task-intake mode, temporarily disable wake requirement
        wake_required = self.cfg.wake_required
        if self._expecting_tasks:
            wake_required = False

        r = route_text(
            raw,
            wake_required=wake_required,
            priority_enabled=self.cfg.priority_enabled,
            awake=self.store.state.awake,
        )
        kind = getattr(r, "kind", "LLM_FALLBACK")
        meta = getattr(r, "meta", {}) or {}
        cleaned = getattr(r, "cleaned", "")

        # Handle task intake (phase 1)
        if self._expecting_tasks and kind in ("LLM_FALLBACK", "NUDGE_WAKE"):
            self._expecting_tasks = False
            return self._capture_tasks(raw)

        if kind == "ASLEEP_IGNORE":
            return ""
        if kind == "WAKE":
            self.store.wake()
            return "I’m awake."
        if kind == "NUDGE_WAKE":
            return "Say 'Hey Vera' first, then ask your question."
        if kind == "SLEEP":
            self.store.sleep()
            return "Going to sleep. Say 'Hey Vera' to wake me."
        if kind == "MISSION":
            return MISSION_TEXT
        if kind == "TIME":
            return self._handle_time()
        if kind == "START_DAY":
            date_str, time_str = self._now_str()
            p = self.store.get_priority()
            priority_line = f"Top priority: {p}." if p else "You haven’t set a top priority yet."
            self._expecting_tasks = True
            return f"Today is {date_str}. It’s {time_str}. {priority_line} Tell me your tasks for today—include times if you can. Example: finish Phase 1, create UI, walk Moose at 3pm."
        if kind == "SCREEN_SUMMARY":
            return "Screen summary is not available yet."
        if kind == "OPEN_LINK":
            return self._handle_open_link(meta.get("target"))
        if kind == "PRIORITY_SET":
            return self._handle_priority_set(str(meta.get("value", "")).strip())
        if kind == "PRIORITY_GET":
            return self._handle_priority_get()
        if kind == "WEB_LOOKUP":
            q = str(meta.get("query", cleaned)).strip()
            return self._handle_web_lookup(q)
        if kind == "SPOTIFY":
            return self._handle_spotify(meta)

        # Manual planner commands
        c = (cleaned or "").lower().strip().strip(".,!?;:")
        if c in ("build my schedule", "build schedule", "make my schedule", "plan my day", "create my schedule"):
            return self._build_schedule()

        return "Ask me directly — I’ll answer."

    def run(self) -> None:
        if configure_sounddevice is not None:
            configure_sounddevice()

        print(f"VERA: {GREET_TEXT}")
        self.speak(GREET_TEXT)

        while True:
            # Reminders tick before listening
            self._tick_reminders()

            print("[STAGE] LISTEN")
            raw = (self.listener.listen() or "").strip()
            if not raw:
                continue
            print(f"[RAW] {raw}")
            print(f"USER: {raw}")

            out = (self.process_one(raw) or "").strip()
            if out:
                print(f"VERA: {out}")
                self.speak(out)

            # Reminders tick after processing
            self._tick_reminders()


def run() -> None:
    VeraApp().run()