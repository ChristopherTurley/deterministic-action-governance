from __future__ import annotations

import os
import subprocess
from dataclasses import dataclass


@dataclass
class SpeakerConfig:
    enabled: bool = True
    voice: str | None = None
    rate: int | None = None


class Speaker:
    """
    macOS TTS speaker.
    Supports:
      - say(text)
      - say_blocking(text)
    """

    def __init__(self, config: SpeakerConfig | None = None) -> None:
        self.config = config or SpeakerConfig()
        self._proc: subprocess.Popen[str] | None = None

    def _cmd(self, text: str) -> list[str]:
        cmd = ["say"]
        if self.config.voice:
            cmd += ["-v", self.config.voice]
        if self.config.rate:
            cmd += ["-r", str(self.config.rate)]
        cmd.append(text)
        return cmd

    def stop(self) -> None:
        if self._proc and self._proc.poll() is None:
            try:
                self._proc.terminate()
            except Exception:
                pass
        self._proc = None

    
    def say(self, text: str) -> None:
        """Blocking TTS. Uses macOS 'say' synchronously."""
        msg = (text or "").strip()
        if not msg:
            return
        if not getattr(self, "cfg", None) or getattr(self.cfg, "enabled", True) is False:
            return
        try:
            # Blocking call â€“ prevents LISTEN starting while TTS is still playing
            subprocess.run(["say", msg], check=False)
        except Exception as e:
            print(f"[AUDIO] say() failed: {e}")
    
    def say_blocking(self, text: str) -> None:
        """Compatibility alias."""
        self.say(text)
    def say_blocking(self, text: str) -> None:
        if not self.config.enabled:
            return
        text = (text or "").strip()
        if not text:
            return
        if os.environ.get("VERA_TTS", "1") in ("0", "false", "False"):
            return

        try:
            subprocess.run(self._cmd(text), check=False)
        except Exception:
            pass
